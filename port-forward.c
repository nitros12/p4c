/* Automatically generated by p4c-ubpf from backends/ubpf/examples/port-forwarding.p4 on Wed Feb 24 15:31:04 2021
 */
#include "port-forward.h"
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include "ubpf_common.h"

#define BPF_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)

void* memcpy(void* dest, const void* src, size_t num);

static void *(*ubpf_map_lookup)(const void *, const void *) = (void *)1;
static int (*ubpf_map_update)(void *, const void *, void *) = (void *)2;
static int (*ubpf_map_delete)(void *, const void *) = (void *)3;
static int (*ubpf_map_add)(void *, const void *) = (void *)4;
static uint64_t (*ubpf_time_get_ns)() = (void *)5;
static uint32_t (*ubpf_hash)(const void *, uint64_t) = (void *)6;
static void (*ubpf_printf)(const char *fmt, ...) = (void *)7;
static void *(*ubpf_packet_data)(const void *) = (void *)9;
static void *(*ubpf_adjust_head)(const void *, uint64_t) = (void *)8;
static uint32_t (*ubpf_truncate_packet)(const void *, uint64_t) = (void *)11;


#define write_partial(a, w, s, v) do { *((uint8_t*)a) = ((*((uint8_t*)a)) & ~(BPF_MASK(uint8_t, w) << s)) | (v << s) ; } while (0)
#define write_byte(base, offset, v) do { *(uint8_t*)((base) + (offset)) = (v); } while (0)

static uint32_t
bpf_htonl(uint32_t val) {
    return htonl(val);
}
static uint16_t
bpf_htons(uint16_t val) {
    return htons(val);
}
static uint64_t
bpf_htonll(uint64_t val) {
    return htonll(val);
}

struct ubpf_map_def pipe_test_tbl = {
    .type = UBPF_MAP_TYPE_HASHMAP,
    .key_size = sizeof(struct pipe_test_tbl_key),
    .value_size = sizeof(struct pipe_test_tbl_value),
    .max_entries = 65535,
    .nb_hash_functions = 0,
};
struct ubpf_map_def pipe_test_tbl_defaultAction = {
    .type = UBPF_MAP_TYPE_ARRAY,
    .key_size = sizeof(uint32_t),
    .value_size = sizeof(struct pipe_test_tbl_value),
    .max_entries = 1,
    .nb_hash_functions = 0,
};
inline uint16_t csum16_add(uint16_t csum, uint16_t addend) {
    uint16_t res = csum;
    res += addend;
    return (res + (res < addend));
}
inline uint16_t csum16_sub(uint16_t csum, uint16_t addend) {
    return csum16_add(csum, ~addend);
}
inline uint16_t csum_replace2(uint16_t csum, uint16_t old, uint16_t new) {
    return (~csum16_add(csum16_sub(~csum, old), new));
}

inline uint16_t csum_fold(uint32_t csum) {
    uint32_t r = csum << 16 | csum >> 16;
    csum = ~csum;
    csum -= r;
    return (uint16_t)(csum >> 16);
}
inline uint32_t csum_unfold(uint16_t csum) {
    return (uint32_t)csum;
}
inline uint32_t csum32_add(uint32_t csum, uint32_t addend) {
    uint32_t res = csum;
    res += addend;
    return (res + (res < addend));
}
inline uint32_t csum32_sub(uint32_t csum, uint32_t addend) {
    return csum32_add(csum, ~addend);
}
inline uint16_t csum_replace4(uint16_t csum, uint32_t from, uint32_t to) {
    uint32_t tmp = csum32_sub(~csum_unfold(csum), from);
    return csum_fold(csum32_add(tmp, to));
}
uint64_t entry(void *ctx, struct standard_metadata *std_meta){
    void *pkt = ubpf_packet_data(ctx);
    uint32_t pkt_len = std_meta->packet_length;
    struct Headers_t hdr = {
        .ethernet = {
            .ebpf_valid = 0
        },
        .ipv4 = {
            .ebpf_valid = 0
        },
    };
    struct metadata meta = {
    };
    int packetOffsetInBits = 0;
    uint8_t pass = 1;
    uint8_t hit = 0;
    unsigned char ebpf_byte;
    uint32_t ebpf_zero = 0;
    int packetTruncatedSize = -1;

    goto start;
    start: {
        /* extract(hdr.ethernet)*/
        if (pkt_len < BYTES(packetOffsetInBits + 112)) {
            goto reject;
        }
        
        hdr.ethernet.dstAddr = (uint64_t)((load_dword(pkt, BYTES(packetOffsetInBits)) >> 16) & BPF_MASK(uint64_t, 48));
        packetOffsetInBits += 48;

        hdr.ethernet.srcAddr = (uint64_t)((load_dword(pkt, BYTES(packetOffsetInBits)) >> 16) & BPF_MASK(uint64_t, 48));
        packetOffsetInBits += 48;

        hdr.ethernet.etherType = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        hdr.ethernet.ebpf_valid = 1;
        switch (hdr.ethernet.etherType) {
            case 2048: goto parse_ipv4;
            default: goto accept;
        }
    }
    parse_ipv4: {
        /* extract(hdr.ipv4)*/
        if (pkt_len < BYTES(packetOffsetInBits + 160)) {
            goto reject;
        }
        
        hdr.ipv4.version = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits)) >> 4) & BPF_MASK(uint8_t, 4));
        packetOffsetInBits += 4;

        hdr.ipv4.ihl = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits))) & BPF_MASK(uint8_t, 4));
        packetOffsetInBits += 4;

        hdr.ipv4.diffserv = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 8;

        hdr.ipv4.totalLen = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        hdr.ipv4.identification = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        hdr.ipv4.flags = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits)) >> 5) & BPF_MASK(uint8_t, 3));
        packetOffsetInBits += 3;

        hdr.ipv4.fragOffset = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))) & BPF_MASK(uint16_t, 13));
        packetOffsetInBits += 13;

        hdr.ipv4.ttl = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 8;

        hdr.ipv4.protocol = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 8;

        hdr.ipv4.hdrChecksum = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        hdr.ipv4.srcAddr = (uint32_t)((load_word(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 32;

        hdr.ipv4.dstAddr = (uint32_t)((load_word(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 32;

        hdr.ipv4.ebpf_valid = 1;
        goto accept;
    }

    reject: { return 1; }

    accept:
    {
        uint8_t i0_0;
        {

            i0_0 = 0;
            {
                /* construct key */
                struct pipe_test_tbl_key key = {};
                key.std_meta_input_port = std_meta->input_port;
                /* value */
                struct pipe_test_tbl_value *value = NULL;
                /* perform lookup */
                value = ubpf_map_lookup(&pipe_test_tbl, &key);

                if (value == NULL) {
                    /* miss; find default action */
                    hit = 0;
                    value = ubpf_map_lookup(&pipe_test_tbl_defaultAction, &ebpf_zero);
                } else {
                    hit = 1;
                }
                if (value != NULL) {
                    /* run action */
                    switch (value->action) {
                        case pipe_mod_nw_tos: 
                        {
                            hdr.ipv4.diffserv = i0_0 + 1;std_meta->output_action = REDIRECT;std_meta->output_port = value->u.pipe_mod_nw_tos.out_port;i0_0 = i0_0 + 1;
                        }
                        break;
                        case pipe_test_tbl_NoAction: 
                        {
                            
                        }
                        break;
                        default: return 1;
                    }
                }
                else return 1;
            }
;

        }    }
    deparser:
    {
        int outHeaderLength = 0;
        {
if (hdr.ethernet.ebpf_valid) 
            outHeaderLength += 112;

            if (hdr.ipv4.ebpf_valid) 
            outHeaderLength += 160;

        }
        int outHeaderOffset = BYTES(outHeaderLength) - BYTES(packetOffsetInBits);
        pkt = ubpf_adjust_head(ctx, outHeaderOffset);
        pkt_len += outHeaderOffset;
        packetOffsetInBits = 0;
        if (packetTruncatedSize > 0) {
            pkt_len -= ubpf_truncate_packet(ctx, packetTruncatedSize);
        }
        
        if (hdr.ethernet.ebpf_valid) {
            if (pkt_len < BYTES(packetOffsetInBits + 112)) {
                goto reject;
            }
            
            hdr.ethernet.dstAddr = htonll(hdr.ethernet.dstAddr << 16);
            ebpf_byte = ((char*)(&hdr.ethernet.dstAddr))[0];
            write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ethernet.dstAddr))[1];
            write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ethernet.dstAddr))[2];
            write_byte(pkt, BYTES(packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ethernet.dstAddr))[3];
            write_byte(pkt, BYTES(packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ethernet.dstAddr))[4];
            write_byte(pkt, BYTES(packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ethernet.dstAddr))[5];
            write_byte(pkt, BYTES(packetOffsetInBits) + 5, (ebpf_byte));
            packetOffsetInBits += 48;

            hdr.ethernet.srcAddr = htonll(hdr.ethernet.srcAddr << 16);
            ebpf_byte = ((char*)(&hdr.ethernet.srcAddr))[0];
            write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ethernet.srcAddr))[1];
            write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ethernet.srcAddr))[2];
            write_byte(pkt, BYTES(packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ethernet.srcAddr))[3];
            write_byte(pkt, BYTES(packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ethernet.srcAddr))[4];
            write_byte(pkt, BYTES(packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ethernet.srcAddr))[5];
            write_byte(pkt, BYTES(packetOffsetInBits) + 5, (ebpf_byte));
            packetOffsetInBits += 48;

            hdr.ethernet.etherType = bpf_htons(hdr.ethernet.etherType);
            ebpf_byte = ((char*)(&hdr.ethernet.etherType))[0];
            write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ethernet.etherType))[1];
            write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
            packetOffsetInBits += 16;

        }
;        if (hdr.ipv4.ebpf_valid) {
            if (pkt_len < BYTES(packetOffsetInBits + 160)) {
                goto reject;
            }
            
            ebpf_byte = ((char*)(&hdr.ipv4.version))[0];
            write_partial(pkt + BYTES(packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&hdr.ipv4.ihl))[0];
            write_partial(pkt + BYTES(packetOffsetInBits) + 0, 4, 0, (ebpf_byte >> 0));
            packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&hdr.ipv4.diffserv))[0];
            write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
            packetOffsetInBits += 8;

            hdr.ipv4.totalLen = bpf_htons(hdr.ipv4.totalLen);
            ebpf_byte = ((char*)(&hdr.ipv4.totalLen))[0];
            write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ipv4.totalLen))[1];
            write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
            packetOffsetInBits += 16;

            hdr.ipv4.identification = bpf_htons(hdr.ipv4.identification);
            ebpf_byte = ((char*)(&hdr.ipv4.identification))[0];
            write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ipv4.identification))[1];
            write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
            packetOffsetInBits += 16;

            ebpf_byte = ((char*)(&hdr.ipv4.flags))[0];
            write_partial(pkt + BYTES(packetOffsetInBits) + 0, 3, 5, (ebpf_byte >> 0));
            packetOffsetInBits += 3;

            hdr.ipv4.fragOffset = bpf_htons(hdr.ipv4.fragOffset << 3);
            ebpf_byte = ((char*)(&hdr.ipv4.fragOffset))[0];
            write_partial(pkt + BYTES(packetOffsetInBits) + 0, 5, 0, (ebpf_byte >> 3));
            write_partial(pkt + BYTES(packetOffsetInBits) + 0 + 1, 3, 5, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ipv4.fragOffset))[1];
            write_partial(pkt + BYTES(packetOffsetInBits) + 1, 5, 0, (ebpf_byte >> 3));
            packetOffsetInBits += 13;

            ebpf_byte = ((char*)(&hdr.ipv4.ttl))[0];
            write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
            packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&hdr.ipv4.protocol))[0];
            write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
            packetOffsetInBits += 8;

            hdr.ipv4.hdrChecksum = bpf_htons(hdr.ipv4.hdrChecksum);
            ebpf_byte = ((char*)(&hdr.ipv4.hdrChecksum))[0];
            write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ipv4.hdrChecksum))[1];
            write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
            packetOffsetInBits += 16;

            hdr.ipv4.srcAddr = htonl(hdr.ipv4.srcAddr);
            ebpf_byte = ((char*)(&hdr.ipv4.srcAddr))[0];
            write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ipv4.srcAddr))[1];
            write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ipv4.srcAddr))[2];
            write_byte(pkt, BYTES(packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ipv4.srcAddr))[3];
            write_byte(pkt, BYTES(packetOffsetInBits) + 3, (ebpf_byte));
            packetOffsetInBits += 32;

            hdr.ipv4.dstAddr = htonl(hdr.ipv4.dstAddr);
            ebpf_byte = ((char*)(&hdr.ipv4.dstAddr))[0];
            write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ipv4.dstAddr))[1];
            write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ipv4.dstAddr))[2];
            write_byte(pkt, BYTES(packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr.ipv4.dstAddr))[3];
            write_byte(pkt, BYTES(packetOffsetInBits) + 3, (ebpf_byte));
            packetOffsetInBits += 32;

        }
;    }
    if (pass)
        return 1;
    else
        return 0;
}
